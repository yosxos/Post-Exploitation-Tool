use std::fs::{ OpenOptions};
use std::io::{ErrorKind, Read, Write};
use std::net::TcpListener;
use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

const LOCAL: &str = "127.0.0.1:6000";
const MSG_SIZE: usize = 200;

fn sleep() {
    thread::sleep(Duration::from_millis(100));
}
fn get_users(clients:&Arc<Mutex<Vec<String>>>)->String{
    //match msg
    let list =clients.lock().unwrap().to_vec();
    let vvv: String = list.join(" ");
    vvv

}

// Création du fichier log + écriture
fn create_log_file(data: String) -> std::io::Result<()> {
    let mut file = OpenOptions::new()
        .write(true)
        .append(true)
        .open("lines_log.txt")
        .unwrap();

    if let Err(e) = writeln!(file, "{:?}", data) {
        eprintln!("Couldn't write to file: {}", e);
    };
    Ok(())
}


fn main() {
    let server = TcpListener::bind(LOCAL).expect("Listener failed to bind");
    server.set_nonblocking(true).expect("failed to initialize non-blocking");

    let mut clients = vec![];
    let  clients_list = Arc::new(Mutex::new(Vec::new()));
    let (tx, rx) = mpsc::channel::<(i32,String,String)>();

    loop {
        if let Ok((mut socket, addr)) = server.accept() {
            println!("Client {} connected", addr);

            let tx = tx.clone();
            clients.push(socket.try_clone().expect("failed to clone client"));
            let cc=Arc::clone(&clients_list); 
            cc.lock().unwrap().push(socket.try_clone().expect("failed to clone client").peer_addr().unwrap().to_string());

            thread::spawn({let cc=Arc::clone(&clients_list); 
             move || loop {
                
               
                let mut buff = vec![0; MSG_SIZE];
                match socket.read_exact(&mut buff) {
                    Ok(_) => {
                        let msg = buff.into_iter().take_while(|&x| x != 0).collect::<Vec<_>>();
                        let msg = String::from_utf8(msg).expect("Invalid utf8 message");
                        println!("{}: {:?}", addr, msg);
                        // Ecrit msg dans le fichier lines_log.txt
                        create_log_file(msg.clone()).ok();
                        // case match here for other commands
                        //to send to other users: let u:32=1
                        // to receive return of command :let u:32=0
                        if msg== "users"{
                        let u:i32=0;
                           let msg_command= get_users(&cc);
                           tx.send((u,socket.peer_addr().unwrap().to_string(),msg_command)).expect("failed to send msg to rx")
                        }
                        if msg =="getlogs"{
                            let u:i32=0;
                            let msg_logs:String;
                            tx.send((u,msg_logs)).expect("failed to send msg to rx")

                        }
                        else {
                            let u:i32=1;
                            tx.send((u,socket.peer_addr().unwrap().to_string(),msg)).expect("failed to send msg to rx");
                        }

                    },
                    Err(ref err) if err.kind() == ErrorKind::WouldBlock => (),
                    Err(_) => {
                            cc.lock().unwrap().retain(|x| *x != addr.to_string());
                        print!("users left :{:?}",cc.lock().unwrap().to_vec());
                        println!("closing connection with: {}", addr);
                        break;
                    }
                }
                sleep();
            }});
        }
        if let Ok(msg) = rx.try_recv() {
            // to send command to others
            if msg.0 == 1{
                clients = clients.into_iter().filter_map(|mut client| {
                    if client.peer_addr().unwrap().to_string() != msg.1
                    {
                        let mut buff = msg.2.clone().into_bytes();
                        buff.resize(MSG_SIZE, 0);
                        client.write_all(&buff).map(|_| client).ok()
                    }
                    else {Some(client)}
                }).collect::<Vec<_>>();
            }

            else{
            // receive requests
            clients = clients.into_iter().filter_map(|mut client| {
                if client.peer_addr().unwrap().to_string() == msg.1
                {
                    let mut buff = msg.2.clone().into_bytes();
                    buff.resize(MSG_SIZE, 0);
                    client.write_all(&buff).map(|_| client).ok()
                }
                else {Some(client)}
            }).collect::<Vec<_>>();}
        }
        sleep();
    }
}