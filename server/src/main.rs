use std::fs::{self, OpenOptions};
use std::io::{ErrorKind, Read, Write};
use std::net::TcpListener;
use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

const LOCAL: &str = "127.0.0.1:6000";
const MSG_SIZE: usize = 200;

fn sleep() {
    thread::sleep(Duration::from_millis(100));
}

/// This method return the users who are connected to the server
fn get_users(clients: &Arc<Mutex<Vec<String>>>) -> String {
    let list = clients.lock().unwrap().to_vec();
    let users: String = list.join(" ");
    users
}

/// This method read the logs from the file `lines_logs.txt` and return them as a String
fn get_logs() -> String {
     fs::read_to_string("src/data/lines_log.txt").expect("Unable to read file")
    
     
}

/// This method create a log file and write in it all the logs that are passed in the server
fn create_log_file(logs: &str, address: &str){
    let mut file = OpenOptions::new()
        .write(true)
        .append(true)
        .open("src/data/lines_log.txt")
        .unwrap();

    if let Err(e) = writeln!(file, "{} : {:?}", address, logs) {
        eprintln!("Couldn't write to file: {}", e);
    };
}

/// This method is used to tranfer a file from a path to a path (ex: from beacon to client)
fn transfer_file(from_path: &str, to_path: &str) -> std::io::Result<()> {
    // Read the file we want to transfer
    let data = fs::read(from_path)?;

    // Write the data where we want to transfer
    fs::write(to_path, data)?;
    Ok(())
}

fn main() {
    let server = TcpListener::bind(LOCAL).expect("Listener failed to bind");
    server
        .set_nonblocking(true)
        .expect("failed to initialize non-blocking");

    let mut clients = vec![];
    let clients_list = Arc::new(Mutex::new(Vec::new()));
    //tx and rx are the sender and receiver that we will use in our program
    let (tx, rx) = mpsc::channel::<(i32, String, String)>();

    loop {
        if let Ok((mut socket, address)) = server.accept() {
            println!("Client {} connected", address);

            let tx = tx.clone();
            clients.push(socket.try_clone().expect("failed to clone client"));
            let listusersconnected = Arc::clone(&clients_list);
            listusersconnected.lock().unwrap().push(
                socket
                    .try_clone()
                    .expect("failed to clone client")
                    .peer_addr()
                    .unwrap()
                    .to_string(),
            );

            thread::spawn({
                let userconnected = Arc::clone(&clients_list);
                move || loop {
                    let mut buff = vec![0; MSG_SIZE];
                    match socket.read_exact(&mut buff) {
                        Ok(_) => {
                            let msg = buff.into_iter().take_while(|&x| x != 0).collect::<Vec<_>>();
                            let msg = String::from_utf8(msg).expect("Invalid utf8 message");
                            println!("{}: {:?}", address, msg);
                            // Write the logs in the file lines_log.txt
                            create_log_file(msg.clone().as_str(), address.clone().to_string().as_str());
                            // case match here for other commands
                            //to send to other users: let u:32=1
                            // to receive return of command :let u:32=0
                            if msg == "users" {
                                let u: i32 = 0;
                                let msg_command = get_users(&userconnected);
                                tx.send((u, socket.peer_addr().unwrap().to_string(), msg_command))
                                    .expect("failed to send msg to rx");
                            }
                            // Get the logs from lines_log.txt, convert the file into a string and send the string to the client
                            else if msg == "getlogs" {
                                let u: i32 = 0;
                                let data: String = get_logs();
                                tx.send((u, socket.peer_addr().unwrap().to_string(), data))
                                    .expect("failed to send msg to rx");
                            }
                            // Upload a file from the client to the beacon
                            else if msg == "upload" {
                                transfer_file("../client/data/interesting_file","../beacon/data/interesting_file").ok();
                            }
                            // Download a file from the beacon to the client
                            else if msg == "download" {
                                transfer_file("../beacon/data/interesting_file","../client/data/interesting_file").ok();
                            } 
                            else {
                                let u: i32 = 1;
                                tx.send((u, socket.peer_addr().unwrap().to_string(), msg))
                                    .expect("failed to send msg to rx");
                            }
                        }
                        Err(ref err) if err.kind() == ErrorKind::WouldBlock => (),
                        Err(_) => {
                            userconnected.lock().unwrap().retain(|x| *x != address.to_string());
                           
                            println!("closing connection with: {}", address);
                            break;
                        }
                    }
                    sleep();
                }
            });
        }
        if let Ok(msg) = rx.try_recv() {
            // to send command to others
            if msg.0 == 1 {
                clients = clients
                    .into_iter()
                    .filter_map(|mut client| {
                        if client.peer_addr().unwrap().to_string() == msg.1 {
                            Some(client)
                        } else {
                            
                            let mut buff = msg.2.clone().into_bytes();
                            buff.resize(MSG_SIZE, 0);
                            client.write_all(&buff).map(|_| client).ok()
                        }
                    })
                    .collect::<Vec<_>>();
            } else {
                // receive requests
                clients = clients
                    .into_iter()
                    .filter_map(|mut client| {
                        if client.peer_addr().unwrap().to_string() == msg.1 {
                            let mut buff = msg.2.clone().into_bytes();
                            buff.resize(MSG_SIZE, 0);
                            client.write_all(&buff).map(|_| client).ok()
                        } else {
                            Some(client)
                        }
                    })
                    .collect::<Vec<_>>();
            }
        }
        sleep();
    }
}
