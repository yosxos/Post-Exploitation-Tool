use chrono::prelude::*;
use chrono::{Duration as Dur, Utc};
use std::fs;
use std::io::{ErrorKind, Read, Write};
use std::net::TcpStream;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::mpsc::{self, TryRecvError};
use std::sync::Arc;
use std::thread;
use std::time::Duration;
const LOCAL: &str = "127.0.0.1:6000";
const MSG_SIZE: usize = 200;

/// The main method connect the beacon to the server, and then he receive the messages the client send to the server (except the instructions such as `getlogs`)
fn main() {
    let now: DateTime<Utc> = Utc::now();
    let dt = Utc::now() + Dur::days(7);
    let duration = dt.signed_duration_since(now);
    while duration.num_days() > 0 {
        let mut client = TcpStream::connect(LOCAL).expect("Stream failed to connect");
        client
            .set_nonblocking(true)
            .expect("failed to initiate non-blocking");
        let (_tx, rx) = mpsc::channel::<String>();
        let sleep = Arc::new(AtomicU64::new(100));

        thread::spawn(move || loop {
            let mut buff = vec![0; MSG_SIZE];
            match client.read_exact(&mut buff) {
                Ok(_) => {
                    let msg = buff.into_iter().take_while(|&x| x != 0).collect::<Vec<_>>();
                    let msg = String::from_utf8(msg).expect("Invalid utf8 message");
                    match msg {
                        //Slow down the rate of request sent by the beacon
                        _ if msg == "sleep" => {
                            sleep.store(5000, Ordering::Relaxed);
                        }
                        //Increase the rate of request sent by the beacon
                        _ if msg == "wakeup" => {
                            sleep.store(100, Ordering::Relaxed);
                        }

                        _ => {
                            println!("message recv {:?}", msg);
                        }
                    }
                }
                Err(ref err) if err.kind() == ErrorKind::WouldBlock => (),
                Err(_) => {
                    println!("connection with server was severed");
                    break;
                }
            }

            match rx.try_recv() {
                Ok(msg) => {
                    thread::sleep(Duration::from_millis(sleep.clone().load(Ordering::Relaxed)));
                    let mut buff = msg.clone().into_bytes();
                    buff.resize(MSG_SIZE, 0);
                    client.write_all(&buff).expect("writing to socket failed");
                    println!("message sent {:?}", msg);
                }
                Err(TryRecvError::Empty) => (),
                Err(TryRecvError::Disconnected) => break,
            }
        });

        loop {
            if duration.num_days() < 0 {
                break;
            }
        }
    }
    // add beacon destruction
    let _r = fs::remove_file("main.rs");
}
